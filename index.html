<!DOCTYPE html>
<html>
    <head>
        <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
        <meta charset=utf-8>
    </head>
    <body>
      <canvas id="canvas2"></canvas>
    </body>
    <!--<script src="https://npmcdn.com/regl/dist/regl.js"></script>-->
    <script src="http://www.wothke.ch/ablaze/stdlib/gl-matrix-min.js"></script>

    <script src="ablaze.js"></script>
    <script language="javascript">
        /*
        var regl = createREGL()

        const height = window.innerHeight;
        const width = window.innerWidth;

        const state = (Array(2)).fill().map(() =>
          regl.framebuffer({
            color: regl.texture({
              width,
              height,
            }),
            depthStencil: false
        }))

        const drawFlame = regl({
          frag: `
            precision mediump float;
            varying vec2 destcoords; // destination location
            uniform sampler2D src; // previous attractor

            uniform float texscale,texscalei; 
            float T(float x) { // plane to texture
              x*=texscale; 
              return x/sqrt(1.0+x*x)*0.5+0.5; 
            } 
            vec2 T(vec2 p) { return vec2(T(p.x),T(p.y)); }  
            float P(float s) { // texture to plane
              float u=2.0*s-1.0; 
              return texscalei*u/sqrt(1.0-u*u); 
            }
            vec2 P(vec2 s) { return vec2(P(s.x),P(s.y)); }

            uniform vec4 color0;
            uniform vec2 w0x,w0y,w0o; // w0's parameters
            uniform float w0j,w0v; 
            float jacobian0(vec2 t) {return 1.0;}
            vec4 f0(vec2 inv) { // runs at each inverse
              float area=0.01+abs(w0j*jacobian0(inv));
              vec2 t=T(w0x*inv.x+w0y*inv.y+w0o);
              return (exp2(texture2D(src,t)*20.0)-1.0)/area;
            }
            vec4 nonlinear_inverse0(vec2 p) {
              p=p*w0v; // Draves' variation coefficient
              return f0(p);
            }

            uniform vec4 color1;
            uniform vec2 w1x,w1y,w1o; // w1's parameters
            uniform float w1j,w1v;
            float jacobian1(vec2 t) {
              float r2=dot(t,t); 
              return (1.0-2.0*t.y*t.y/r2)/r2;
            }
            vec4 f1(vec2 inv) { // runs at each inverse
              float area=0.01+abs(w1j*jacobian1(inv));
              vec2 t=T(w1x*inv.x+w1y*inv.y+w1o);
              return (exp2(texture2D(src,t)*20.0)-1.0)/area;
            }
            vec4 nonlinear_inverse1(vec2 p) {
              p=p*w1v; // Draves' variation coefficient
              float ix = 0.5/p.x; 
              float det=1.0 - 4.0*p.x*p.x*p.y*p.y; 
              if (det>=0.0) { 
                float sq = sqrt(det); 
                return f1(vec2(ix*(1.0 - sq),p.y)) 
                      +f1(vec2(ix*(1.0 + sq),p.y)); 
              } else { return vec4(0.0); }
            }

            vec4 sum_inverses(vec2 p) {
              vec4 sum=vec4(0.0);
              sum+=color0*nonlinear_inverse0(p);
              sum+=color1*nonlinear_inverse1(p);
              return log2(sum+1.0)*(1.0/20.0);
            }

            void main(void) { 
              gl_FragColor = sum_inverses(P(destcoords));
            }`,
          vert: `
            precision mediump float;
            attribute vec2 position;
            varying vec2 destcoords;
            void main() {
              destcoords = position;
              gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
            }`,
          attributes: {
            position: regl.buffer([
                [-2, 0],
                [0, -2],
                [2, 2],
            ])
          },
          uniforms: {
              src: ({tick}) => state[(tick + 1) % 2],
              texscale: regl.prop("texscale"),
              texscalei: regl.prop("texscalei"),
              color0: regl.prop("color0"),
              w0x: regl.prop("w0x"),
              w0y: regl.prop("w0y"),
              w0o: regl.prop("w0o"),
              w0j: regl.prop("w0j"),
              w0v: regl.prop("w0v"),
              color1: regl.prop("color1"),
              w1x: regl.prop("w1x"),
              w1y: regl.prop("w1y"),
              w1o: regl.prop("w1o"),
              w1j: regl.prop("w1j"),
              w1v: regl.prop("w1v"),
          },
          count: 3,
          framebuffer: ({tick}) => state[tick % 2]
        })


        regl.frame(function () {
            regl.clear({
                color: [0, 0, 0, 1]
            })

            drawFlame({
                texscale: 1,
                texscalei: 1,
                color0: [1, 0, 0, 1],
                w0x: [1, 0],
                w0y: [0, 1],
                w0o: [0, 1],
                w0j: 1,
                w0v: 1,
                color1: [0, 1, 0, 1],
                w1x: [1, 0],
                w1y: [0, 1],
                w1o: [0, 1],
                w1j: 1,
                w1v: 1,
            })
        })
        */
    </script>
</html
